<!DOCTYPE html><html><head><title>2018-09-25</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style></style></head><body><div id='preview-contents' class='note-content'>
                        
                    



<h1 id="2018-09-25"><center>2018-09-25</center></h1>



<h2 id="pdf解析">pdf解析</h2>



<h4 id="根据坐标">根据坐标</h4>

<p>根据坐标来判断表格，主要是根据坐标的对应关系，而坐标的对应关系最终落实在单元格起始和结束。</p>

<p>总的来说，表格分为左对齐，右对齐和居中对齐，对于这三种情况都可以归纳为起点坐标相同或者终点坐标相同。</p>

<p>或者，另一个层面来说，是单元格个数相同，且对应单元格的距离相等。即一旦出现超过两行单元格个数相同，或者超过两行（每行每个）单元格起始坐标或结束坐标相同，即将其初步判断为表格。</p>

<p>即，先数个数，再算起始坐标，以及宽度。</p>



<h2 id="pdf解析思路整理">pdf解析思路整理</h2>

<p>先将pdf分解，解析到每一个字符，该节点携带了确定该字符的所有信息，（此处图片无法解析）。</p>

<p>每一个字符都携带了其必须的信息后，对其进行建模。</p>



<h2 id="建模起点宽度高度字符模型">建模——起点+宽度+高度+字符模型</h2>

<p>如前所述，pdf里的任何对象都是此模型，该模型具有通用性。</p>



<h2 id="假设">假设</h2>



<h3 id="假设1行划分节点正确">假设1——行划分节点正确</h3>

<p>假设对每一页pdf的每一行的节点划分都正确，具体为节点个数正确、节点起始坐标、高度、宽度、正确。</p>



<h3 id="假设2单元格规整">假设2——单元格规整</h3>

<p>假设单元格规整，即单元格不存在跨行跨列，且每一行个数相同。</p>



<h2 id="实际情况">实际情况</h2>

<p>1.并不是每一行的节点划分都正确。 <br>
2.并不是所有行都具有相同的节点数。 <br>
3.真正规整的表格较少，绝大多数存在跨行跨列。</p>



<h2 id="整合折中">整合折中</h2>

<table><tbody><tr><td bgcolor="Khaki">
但一个表格中至少有相连两行节点数相同，也不存在跨行跨列。
这将作为先判断表格中间行的依据。</td></tr></tbody></table>



<h2 id="判断表格">判断表格</h2>

<p>第一遍先计算节点数，当节点数符合条件，计算距离。当两者均满足条件时，确定表格，然后再根据起始点和距离去寻找表格边框。</p>



<h1 id="2018-09-26"><center>2018-09-26</center></h1>



<h2 id="pdf解析-1">pdf解析</h2>

<p>最终得到page，其内含有三个对象，代码如下：</p>



<pre class="prettyprint hljs-dark"><code class="hljs dart"><div class="hljs-line">    <span class="hljs-comment">//存放不根据表格线解析的表格所在的行索引</span>
</div><div class="hljs-line">    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span> []&gt; form=<span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">int</span>[]&gt;();
</div><div class="hljs-line">    <span class="hljs-comment">//存放根据表格线解析的表格信息</span>
</div><div class="hljs-line">    <span class="hljs-built_in">List</span>&lt;Form&gt; forms=<span class="hljs-keyword">new</span> ArrayList&lt;Form&gt;();
</div><div class="hljs-line">    <span class="hljs-comment">//存放所有的文本内容</span>
</div><div class="hljs-line">    <span class="hljs-built_in">List</span>&lt;TextRow&gt; content=<span class="hljs-keyword">new</span> ArrayList&lt;TextRow&gt;();
</div></code></pre>



<h2 id="static关键字修饰方法时方便在没有创建对象的情况下来进行调用">static关键字(修饰方法时方便在没有创建对象的情况下来进行调用)</h2>



<h3 id="static方法">static方法</h3>

<blockquote>
  <p>static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。</p>
</blockquote>

<p>static方法不依赖于任何对象就可以进行访问，即非static方法需要先建一个对象才可以进行访问。在static方法中不能访问类的非static成员变量和非static方法，因为非static方法/变量都必须依赖具体的对象才能被调用。但在非static成员方法中可以访问static方法/变量。</p>



<h3 id="static变量">static变量</h3>

<p>static变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</p>



<h2 id="final关键字">final关键字</h2>

<p>java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。</p>



<h3 id="修饰类">修饰类</h3>

<p>final修饰类，表示这个类不能被继承。</p>



<h3 id="修饰方法">修饰方法</h3>

<blockquote>
  <p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p>
</blockquote>

<p>因此，只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。</p>

<p>注：类的private方法会隐式地被指定为final方法。</p>



<h1 id="2018-09-27"><center>2018-09-27</center></h1>



<h2 id="java-abstract关键字">java abstract关键字</h2>



<h3 id="抽象方法">抽象方法</h3>

<p>1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法</p>

<p>2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来说是不能访问的，所以就会产生矛盾</p>

<p>3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。</p>



<h3 id="抽象类">抽象类</h3>

<p>1、用abstract关键字来表达的类，其表达形式为：（public）abstract class 类名{}。</p>

<p>2、抽象类不能被实例化，也就是说我们没法直接new 一个抽象类。抽象类本身就代表了一个类型，无法确定为一个具体的对象，所以不能实例化就合乎情理了，只能有它的继承类实例化。</p>

<p>3、抽象类虽然不能被实例化，但有自己的构造方法。</p>

<p>4、抽象类与接口（interface）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。</p>

<p>5、抽象类不能使用finally关键字修饰，因为finally修饰的类是无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法，这又会产生矛盾。</p>



<h3 id="抽象类与抽象方法的关联">抽象类与抽象方法的关联</h3>

<p>如果一个类中至少有一个抽象方法，那么这个类一定是抽象类，但反之则不然。也就是说一个抽象类中可以没有抽象方法。这样做的目的是为了此类不能被实例化。</p>

<p>如果一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类。</p>



<h2 id="java注解">java注解</h2>

<p>Java中的注释主要有以下三种：</p>

<ul><li>Override</li>
<li>Deprecated</li>
<li>SuppressWarning</li>
</ul>

<p>注释是java代码的元数据（所谓元数据，就是数据的数据。也就是说，元数据存在的意义，就是为了描述数据）。</p>

<p>Override是用来标识当前的方法，是否覆盖了它的父类中的方法。 <br>
Deprecated用来标记过时的元素。 <br>
SuppressWarning用来阻止警告。</p>



<h2 id="t-extends-comparable-super-t">&lt;T extends Comparable&lt;? super T\&gt;&gt;</h2>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>{
</div><div class="hljs-line">        list.sort(<span class="hljs-keyword">null</span>);
</div><div class="hljs-line">    }
</div></code></pre>

<p>能调用sort方法进行排序，list中的元素必须是实现了Comparable接口的类或者其子类，通过&lt;T extends Comparable&lt;? super T\&gt;&gt;来进行限定。</p>

<p>Java采取的是类型擦除的方法来实现泛型，并通过extends和super关键字来约束泛型的上界和下界。</p>

<ul><li><p>extends关键字用于确定泛型的上界,&lt;A extends B\&gt;表示类B或者其子类。</p></li>
<li><p>super关键字用于确定泛型的下界，&lt;A super B\&gt;表示类B或者其父类，一直到Object。？则是一个通配符。</p></li>
</ul>

<p>&lt;T extends Compatable&lt;? super T\&gt;&gt;表示了上界为实现了Comparable接口的类，&lt;? super T&gt;则表示实现Comparable接口的类的子类也可以，从而确定下界</p>



<h1 id="2018-09-28"><center>2018-09-28</center></h1>



<h2 id="pdfbox解析说明">pdfbox解析说明</h2>

<p>该项目为pdf无表格线解析，具体为将pdf文件转换为XML格式，方便数据入库。</p>

<p>该项目只提取pdf数据，不对表格进行识别。即除了过滤掉部分多余数据外，保留源文件的所有信息。</p>

<p>该项目最终输出XML文件，方便下游识别表格时对数据的读取。</p>



<h2 id="重点">重点</h2>

<p>所需要的数据主要在表格中，具体表现为：</p>

<p><font color="red"></font></p>

<ul><li>資產負債表（资产负债表）</li>
<li>利潤表（利润表）</li>
<li>現金流量表（现金流量表）</li>
<li>財務報表（财务报表）</li>
<li>股東權益變動表（股东权益变动表）</li>
</ul>

<p></p>

<p>即主要问题转换为对表格的识别判断以及一些附加数据，附加数据主要包括</p>

<p><font color="blue"></font></p>

<ul><li>表格名称</li>
<li>表格发布的时间日期</li>
</ul>

<p></p>



<h2 id="处理">处理</h2>

<p>1.与表格有关的数据必须保留</p>

<ul><li>表格名称</li>
<li>表格发布的时间日期</li>
<li>表的具体内容</li>
</ul>

<p>以上数据不能有任何缺失</p>

<p>2.部分多余数据必须删除</p>

<p><font color="red"></font></p>

<p><del>1.页眉</del></p>

<p><del>2.页脚</del></p>

<p><del>3.页码</del></p>

<p><del>4.下划线</del></p>

<p></p>



<h2 id="操作">操作</h2>

<p>综上，主要涉及两部分操作：</p>

<p>1.对于需要保留的数据，需要 <strong>正确划分节点</strong>；</p>

<p>2.正确识别要删除的数据，<strong>不能误删</strong>。</p>



<h2 id="实现">实现</h2>

<p>采用pdfbox的框架解析出字符串后，再对字符串进行上述的处理。</p>



<h3 id="pdfbox解析字符串">pdfbox解析字符串</h3>

<p>pdfbox解析的主要类是PDFTextStripper，需要对其中的writeString方法进行重写，重点处理对象为List textPositions，具体如下：</p>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextPositonExtracter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFTextStripper</span> </span>{
</div><div class="hljs-line">     <span class="hljs-meta">@Override</span>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeString</span><span class="hljs-params">(String text, List&lt;TextPosition&gt; textPositions)</span> <span class="hljs-keyword">throws</span> IOException </span>{
</div><div class="hljs-line">        <span class="hljs-comment">//textPosition中存放了pdf中每一个字符的坐标，内容，高度，宽度</span>
</div><div class="hljs-line">        <span class="hljs-keyword">for</span>(TextPosition textPosition:textPositions){
</div><div class="hljs-line">            <span class="hljs-comment">//具体的处理逻辑</span>
</div><div class="hljs-line">            <span class="hljs-comment">//包括如何划分节点，如何舍弃多余数据</span>
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line">}
</div></code></pre>



<h3 id="字符识别节点及删除多余数据">字符识别节点及删除多余数据</h3>

<p>目前的节点识别主要包括以下几点：</p>

<p><font color="red"></font></p>

<p>1.下划线直接删除</p>

<p>2.根据空格和距离划分节点</p>

<p>具体为计算第一个空格和最后一个空格的距离，设定一个阀值作为判别依据。</p>

<p>3.特殊标点符号直接处理</p>

<p>如顿号、冒号、括号直接合并。   </p>

<p></p>



<h1 id="2018-09-29"><center>2018-09-29</center></h1>



<h2 id="pdf解析维护调整优化">pdf解析维护、调整、优化</h2>

<p>到目前为止，会出现问题的也只有三个方面：</p>

<ul><li>节点划分</li>
<li>表格缺失</li>
<li>页脚页码未去除</li>
</ul>



<h3 id="节点划分出现问题解决方法">节点划分出现问题解决方法</h3>

<p>1.特殊标点符号划分基本不会有问题；</p>

<p>2.节点划分一个重要参数就是字符阀值上限，该值是划分节点的主要依据。</p>

<p>该值在TextPositonExtracte类中定义。</p>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line">    <span class="hljs-comment">//部分文档解析会误把两个单元格的内容合并到一起,同一个单元格里面内容的最大距离</span>
</div><div class="hljs-line">    <span class="hljs-comment">//目前调整为14，后续若其他方法无法解决节点划分问题时可对其进行修改</span>
</div><div class="hljs-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CHARTHRESHOLD = <span class="hljs-number">14</span>;<span class="hljs-comment">//20;</span>
</div></code></pre>



<h3 id="表格名称误删除问题解决">表格名称误删除问题解决</h3>

<p>查看表名称是否在页的顶部，同时查看表名称的关键字是否包含在用于判断的正则表达式中。 对于表名称主要使用TextPositonExtracte类中的isSpecialChinese进行匹配，主要代码如下：</p>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line"><span class="hljs-comment">//可将新的表关键字加入到该匹配序列解决</span>
</div><div class="hljs-line"> Pattern isSpecialChinese=Pattern.compile(<span class="hljs-string">"^.*表|^.*損益.*|^.*收益.*|^.*全面.*|^.*財務.*|^.*變動.*|^.*损益.*|^.*收益.*|^.*财务.*|^.*資産.*|"</span>
</div><div class="hljs-line">            + <span class="hljs-string">"^.*綜合.*|^.*簡明.*|簡|明|綜|合|損|益|及|其|他|全|面|收|財|務|狀|況|權|變|動|現|金|流|量|简|"</span>
</div><div class="hljs-line">            + <span class="hljs-string">"明|综|财|务|状|况|损|现|权|股|变|动|資|産|產|利|潤|润|併|負|債|東|截|止|年|月|日|[0-9]|料|本|东"</span>);
</div></code></pre>



<h3 id="页脚页码未删除">页脚页码未删除</h3>

<p>删除页脚主要判断每一页底部的三行，即筛选出三个最大的Y坐标，对这三个坐标内的字符进行判别。</p>

<p>代码方法为Pragrom类的RemoveFooter。</p>



<h2 id="java访问权限控制">java访问权限控制</h2>

<p>对于类的成员而言，其能否被其他类所访问，取决于该成员的修饰词；而对于一个类而言，其能否被其他类所访问，也取决于该类的修饰词。在Java中，类成员访问权限修饰词有四类：private，无（包访问权限），protected 和 public，而其中只有包访问权限和public才能修饰一个类（内部类除外）。具体如下：</p>

<ul><li>public ：被public修饰的类成员能被所有的类直接访问</li>
<li>private：被public修饰的类成员只能在定义它的类中被访问，其他类都访问不到。特别地，我们一般建议将成员变量设为private的，并为外界提供 getter/setter 去对成员变量进行访问，这种做法充分体现了Java的封装思想；</li>
<li>包访问权限：包访问权限就是Java中的默认的权限，具有包访问权限的类成员只能被同一包中的类访问</li>
</ul>



<h2 id="protected关键字">protected关键字</h2>

<ul><li>基类的protected成员是包内可见的，并且对子类可见；</li>
<li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li>
</ul>



<h1 id="2018-09-30"><center>2018-09-30</center></h1>



<h2 id="pdf有表格线解析">pdf有表格线解析</h2>

<p>目前，识别出了表格，即表格有多少行，每行有多少个单元格。但里面没有内容，也没有和其他字符串形成一整页文档。</p>



<h3 id="问题如何将表格和表格内的文字合并">问题——如何将表格和表格内的文字合并</h3>

<p>文字识别以行为单位，初步划分了节点。</p>

<p>表格识别也以行为单位，每行有多少节点也进行了标记。</p>

<p>现在需要把表格和表格的文字对应起来，对应主要根据坐标，即每一个单元格用坐标限定，有如下两种思路：</p>

<p>1.遍历文本行，匹配表格，匹配到将其写入； <br>
2.遍历表格，匹配文本行，匹配到将其写入；</p>

<p>经过考虑，决定选用遍历文本行，匹配表格。因为输出为xml文件，不匹配表格就直接将其写入成P标签，匹配则将其写入为table。</p>



<h3 id="程序结构">程序结构</h3>

<p>目前文本已识别成功，主要为两个类：</p>

<ul><li>Cell</li>
<li>Row</li>
</ul>

<p>Cell含有x，y，height，width，text属性，row只是Cell的集合。</p>

<p>现在的主要问题是如何限定表格，按照之前的设计，创建一个Form类，form含有以下属性,必须标明一个表格的开始与结束，有多少行，每行有多少个单元格，每一行，每一个单元格的起始和结束坐标：</p>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line">List&lt;Cell&gt;
</div><div class="hljs-line">List&lt;Row&gt;
</div></code></pre>



<h2 id="程序设计要点">程序设计要点</h2>

<ul><li>逻辑必须清楚</li>
<li>结构必须合理简单</li>
<li>要容易阅读</li>
<li>要便于修改和维护</li>
</ul></div></body></html>